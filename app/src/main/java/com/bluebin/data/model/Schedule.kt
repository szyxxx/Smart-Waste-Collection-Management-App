package com.bluebin.data.model

import com.google.firebase.Timestamp
import com.google.firebase.firestore.DocumentId
import com.google.firebase.firestore.PropertyName

data class Schedule(
    @DocumentId
    val scheduleId: String = "",
    val date: Timestamp = Timestamp.now(),
    val driverId: String = "",
    val tpsRoute: List<String> = emptyList(),
    val status: ScheduleStatus = ScheduleStatus.PENDING,
    val createdAt: Long = System.currentTimeMillis(),
    val completedAt: Long? = null,
    
    // NEW: Fields for AI-generated schedules (mapped to 'optimized' for Firestore compatibility)
    @PropertyName("optimized")
    val isOptimized: Boolean = false,
    @PropertyName("generationType")
    val generationType: ScheduleGenerationType = ScheduleGenerationType.MANUAL,
    @PropertyName("optimizationData")
    val optimizationData: OptimizationData? = null,
    @PropertyName("approvedAt")
    val approvedAt: Long? = null,
    @PropertyName("priority")
    val priority: SchedulePriority = SchedulePriority.NORMAL,
    @PropertyName("estimatedDuration")
    val estimatedDuration: Double = 0.0,
    @PropertyName("totalDistance")
    val totalDistance: Double = 0.0,
    @PropertyName("generatedAt")
    val generatedAt: Long? = null,
    
    // NEW: Route completion data
    @PropertyName("routeCompletionData")
    val routeCompletionData: List<RouteStopCompletion> = emptyList(),
    @PropertyName("startedAt")
    val startedAt: Long? = null,
    
    // NEW: Schedule assignment and recurrence
    @PropertyName("assignedDate")
    val assignedDate: Timestamp? = null,
    @PropertyName("isRecurring")
    val isRecurring: Boolean = false,
    @PropertyName("recurrenceType")
    val recurrenceType: RecurrenceType = RecurrenceType.NONE,
    @PropertyName("nextOccurrence")
    val nextOccurrence: Timestamp? = null
) {
    // No-argument constructor for Firestore
    constructor() : this(
        scheduleId = "",
        date = Timestamp.now(),
        driverId = "",
        tpsRoute = emptyList(),
        status = ScheduleStatus.PENDING,
        createdAt = System.currentTimeMillis(),
        completedAt = null,
        isOptimized = false,
        generationType = ScheduleGenerationType.MANUAL,
        optimizationData = null,
        approvedAt = null,
        priority = SchedulePriority.NORMAL,
        estimatedDuration = 0.0,
        totalDistance = 0.0,
        generatedAt = null,
        routeCompletionData = emptyList(),
        startedAt = null,
        assignedDate = null,
        isRecurring = false,
        recurrenceType = RecurrenceType.NONE,
        nextOccurrence = null
    )
}

enum class ScheduleStatus {
    // For manual schedules
    PENDING, IN_PROGRESS, COMPLETED, CANCELLED,
    
    // For AI-generated schedules (approval workflow)
    PENDING_APPROVAL, APPROVED, ASSIGNED
}

enum class ScheduleGenerationType {
    MANUAL,           // Created manually by admin
    AI_GENERATED,     // Generated by AI route optimization
    CONVERTED         // Converted from optimized to regular
}

enum class SchedulePriority {
    LOW, NORMAL, HIGH, URGENT
}

enum class RecurrenceType {
    NONE,           // No recurrence
    WEEKLY          // Repeat weekly
}

// Simplified optimization data (instead of complex nested objects)
data class OptimizationData(
    @PropertyName("totalDistanceKm")
    val totalDistanceKm: Double = 0.0,
    @PropertyName("estimatedTotalMinutes")
    val estimatedTotalMinutes: Double = 0.0,
    @PropertyName("routeSegments")
    val routeSegments: List<SimpleRouteSegment> = emptyList(),
    @PropertyName("optimizedTpsOrder")
    val optimizedTpsOrder: List<String> = emptyList() // TPS IDs in optimized order
) {
    constructor() : this(0.0, 0.0, emptyList(), emptyList())
}

data class SimpleRouteSegment(
    @PropertyName("from")
    val from: String = "",
    @PropertyName("to") 
    val to: String = "",
    @PropertyName("distanceKm")
    val distanceKm: Double = 0.0,
    @PropertyName("estimatedTimeMinutes")
    val estimatedTimeMinutes: Double = 0.0
) {
    constructor() : this("", "", 0.0, 0.0)
}

// Data class for storing route stop completion details
data class RouteStopCompletion(
    @PropertyName("tpsId")
    val tpsId: String = "",
    @PropertyName("completedAt")
    val completedAt: Long? = null,
    @PropertyName("proofPhotoUrl")
    val proofPhotoUrl: String? = null,
    @PropertyName("notes")
    val notes: String = "",
    @PropertyName("hasIssue")
    val hasIssue: Boolean = false,
    @PropertyName("driverLocation")
    val driverLocation: Map<String, Double>? = null // latitude, longitude
) {
    constructor() : this("", null, null, "", false, null)
} 